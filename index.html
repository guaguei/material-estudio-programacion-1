<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Material de Estudio: Algoritmia y Programación en C</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Material de Estudio</h1>
        <h2>Algoritmia y Programación en Lenguaje C</h2>
        <p>Tecnicatura Universitaria en Programación</p>
    </header>

    <main>
        <section class="unidad">
            <h3>UNIDAD 1 – Introducción a la Algoritmia y al Lenguaje C</h3>
            <p>Esta unidad sienta las bases para comprender cómo las computadoras resuelven problemas. Se explora la lógica detrás de cada acción que una máquina ejecuta, desde la idea abstracta hasta su implementación.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Definición de Proceso:</strong> Un proceso se entiende como una secuencia de pasos o actividades interrelacionadas, diseñadas para lograr un objetivo específico. En computación, a menudo implica la transformación de datos.</li>
                <li><strong>Acciones y Estados:</strong> Las acciones son las operaciones que se realizan, mientras que los estados representan la situación o el valor de los datos en un momento dado antes o después de una acción. Las acciones cambian los estados.</li>
                <li><strong>Representación de Estados:</strong> Cómo se modela y se visualiza la información y las variables en diferentes momentos durante la ejecución de un algoritmo o programa.</li>
                <li><strong>Variables y Constantes:</strong> Son los pilares del almacenamiento de datos. Las <strong>variables</strong> son espacios de memoria con un nombre que pueden cambiar su valor durante la ejecución del programa (ej., la edad de una persona). Las <strong>constantes</strong> son espacios de memoria cuyo valor permanece fijo e inalterable durante toda la ejecución (ej., el valor de PI).</li>
                <li><strong>Definición de Algoritmo:</strong> Un algoritmo es un conjunto finito y ordenado de instrucciones o reglas bien definidas, no ambiguas y precisas, que permiten resolver un problema, realizar un cómputo o procesar datos. Debe ser finito, preciso, definido y efectivo.</li>
                <li><strong>Definición de Programa:</strong> Un programa es la materialización de un algoritmo. Es una secuencia de instrucciones escritas en un lenguaje de programación específico que una computadora puede interpretar y ejecutar para realizar una tarea determinada.</li>
                <li><strong>Lenguajes y Paradigmas:</strong> Un lenguaje de programación es un sistema de notación para escribir programas. Los paradigmas de programación son estilos fundamentales de programación, que definen cómo se conciben y estructuran los programas (ej., imperativo, declarativo, orientado a objetos).</li>
                <li><strong>Tipos de Paradigmas de Programación:</strong> Se abordarán paradigmas como:
                    <ul>
                        <li><strong>Imperativo:</strong> Se centra en "cómo" hacer algo, mediante secuencias de instrucciones que cambian el estado del programa (ej., C, Fortran).</li>
                        <li><strong>Funcional:</strong> Se centra en "qué" hacer, tratando la computación como la evaluación de funciones matemáticas, evitando el cambio de estado y los datos mutables.</li>
                        <li><strong>Orientado a Objetos (POO):</strong> Organiza el diseño del software alrededor de objetos y sus interacciones, que encapsulan datos y comportamientos (ej., C++, Java).</li>
                    </ul>
                </li>
                <li><strong>Buenas prácticas de programación:</strong> Conjunto de convenciones y técnicas recomendadas para escribir código que sea legible, mantenible, eficiente, robusto y escalable. Incluye el uso de comentarios, nombres significativos, indentación adecuada, etc.</li>
                <li><strong>Estructura de un programa en C:</strong> Se estudiarán los elementos básicos de un programa en C, incluyendo la función `main()` (punto de entrada del programa), la inclusión de bibliotecas (`#include`), las declaraciones de variables y las sentencias.
                    <pre><code class="language-c">
#include &lt;stdio.h&gt; // Incluye la biblioteca estándar de entrada/salida

int main() { // Punto de entrada del programa
    // Esto es un comentario de una sola línea
    /*
     * Esto es un
     * comentario de
     * múltiples líneas
     */
    printf("¡Hola, mundo!\n"); // Muestra un mensaje en la consola
    return 0; // Indica que el programa finalizó correctamente
}
                    </code></pre>
                </li>
                <li><strong>Operaciones básicas de salida:</strong> Cómo un programa puede interactuar con el usuario mostrando información en la consola, principalmente utilizando la función `printf()` para imprimir texto, variables y resultados.
                    <pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int edad = 30;
    float altura = 1.75;
    char inicial = 'J';

    printf("Mi edad es: %d años.\n", edad);
    printf("Mi altura es: %.2f metros.\n", altura);
    printf("Mi inicial es: %c.\n", inicial);
    return 0;
}
                    </code></pre>
                </li>
            </ul>
        </section>

        <section class="unidad">
            <h3>Unidad 2 - Estructura de Datos</h3>
            <p>Esta unidad se centra en cómo la información se almacena y se organiza dentro de la memoria de la computadora. Entenderemos los diferentes tipos de datos y cómo se manipulan a través de operadores.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Tipos de Datos:</strong> Clasificación que define el tipo de valores que una variable o constante puede contener y las operaciones que se pueden realizar con ellos (ej., números, caracteres, booleanos).</li>
                <li><strong>Tipos Primitivos de Datos:</strong> Son los tipos de datos fundamentales y predefinidos en un lenguaje de programación, como `int` (enteros), `float` (números de punto flotante), `char` (caracteres).</li>
                <li><strong>Dominio de cada Tipo:</strong> El rango de valores que un tipo de dato específico puede almacenar. Por ejemplo, un `int` puede almacenar números enteros dentro de un cierto rango definido por el sistema.</li>
                <li><strong>Operaciones válidas:</strong> Las acciones permitidas sobre un tipo de dato, como suma para números, concatenación para cadenas, etc.</li>
                <li><strong>Ocupación de Memoria:</strong> La cantidad de bytes que cada tipo de dato requiere para ser almacenado en la memoria RAM de la computadora.</li>
                <li><strong>Punteros (Pointers):</strong>
                    <p>Un puntero es una variable especial que almacena la dirección de memoria de otra variable. En lugar de guardar un valor directamente, guarda la "ubicación" donde se encuentra ese valor. Son fundamentales en C para la asignación dinámica de memoria, el manejo de arreglos de forma eficiente y el paso de argumentos por referencia a funciones.</p>
                    <p><strong>Declaración:</strong> Se usa el asterisco (`*`) para indicar que una variable es un puntero.</p>
                    <pre><code class="language-c">
int *ptr_entero; // Declara un puntero a un entero
float *ptr_flotante; // Declara un puntero a un flotante
                    </code></pre>
                    <p><strong>Operador de Dirección (`&`):</strong> Se usa para obtener la dirección de memoria de una variable.</p>
                    <pre><code class="language-c">
int numero = 10;
int *ptr_numero;
ptr_numero = &numero; // ptr_numero ahora contiene la dirección de memoria de 'numero'
                    </code></pre>
                    <p><strong>Operador de Desreferencia (`*`):</strong> Se usa para acceder al valor almacenado en la dirección de memoria a la que apunta el puntero.</p>
                    <pre><code class="language-c">
int valor_obtenido = *ptr_numero; // valor_obtenido ahora es 10 (el valor de 'numero')
printf("El valor al que apunta ptr_numero es: %d\n", *ptr_numero);
*ptr_numero = 20; // Cambia el valor de 'numero' a través del puntero
printf("El nuevo valor de numero es: %d\n", numero); // Ahora 'numero' es 20
                    </code></pre>
                    <p><strong>Punteros y Arreglos:</strong> En C, el nombre de un arreglo a menudo se comporta como un puntero al primer elemento del arreglo. Esto permite usar aritmética de punteros para recorrer arreglos.</p>
                    <pre><code class="language-c">
int arr[] = {10, 20, 30};
int *p = arr; // p apunta a arr[0]
printf("Primer elemento: %d\n", *p); // 10
printf("Segundo elemento (usando aritmetica de punteros): %d\n", *(p + 1)); // 20
printf("Tercer elemento (usando p[2]): %d\n", p[2]); // 30
                    </code></pre>
                </li>
                <li><strong>Datos Compuestos:</strong> Tipos de datos creados a partir de la combinación de tipos primitivos o de otros tipos compuestos (ej., estructuras, arrays).</li>
                <li><strong>Estructuras de Datos:</strong> Maneras específicas de organizar los datos en la memoria para que puedan ser utilizados de manera eficiente. No son los datos en sí, sino la forma de relacionarlos y acceder a ellos.</li>
                <li><strong>Estructuras estáticas y dinámicas:</strong>
                    <ul>
                        <li><strong>Estáticas:</strong> Su tamaño se define en tiempo de compilación y no puede cambiar durante la ejecución (ej., arrays tradicionales).</li>
                        <li><strong>Dinámicas:</strong> Su tamaño puede crecer o decrecer en tiempo de ejecución, utilizando la asignación dinámica de memoria (ej., listas enlazadas).</li>
                    </ul>
                </li>
                <li><strong>Tipos de Datos: Constantes, variables:</strong> Reafirmación y profundización en la declaración y uso de valores fijos (constantes) y modificables (variables) en el contexto de C.
                    <pre><code class="language-c">
const float PI = 3.14159; // Declaración de una constante
int radio = 5;            // Declaración de una variable
float area;

area = PI * radio * radio; // Asignación de un valor a la variable 'area'
printf("El área del círculo es: %.2f\n", area);

// PI = 3.0; // Esto daría un error, PI es una constante
radio = 7; // Esto es válido, radio es una variable
                    </code></pre>
                </li>
                <li><strong>Operadores matemáticos, relacionales y lógicos:</strong>
                    <ul>
                        <li><strong>Matemáticos:</strong> `+` (suma), `-` (resta), `*` (multiplicación), `/` (división), `%` (módulo).
                            <pre><code class="language-c">
int a = 10, b = 3;
printf("Suma: %d\n", a + b);     // 13
printf("Resta: %d\n", a - b);    // 7
printf("Multiplicación: %d\n", a * b); // 30
printf("División (entera): %d\n", a / b); // 3
printf("Módulo: %d\n", a % b);   // 1 (resto de la división)
                            </code></pre>
                        </li>
                        <li><strong>Relacionales:</strong> `==` (igual a), `!=` (diferente de), `<` (menor que), `>` (mayor que), `<=` (menor o igual que), `>=` (mayor o igual que). Usados para comparar valores.
                            <pre><code class="language-c">
int x = 5, y = 8;
printf("x == y: %d\n", x == y); // 0 (falso)
printf("x < y: %d\n", x < y);   // 1 (verdadero)
                            </code></pre>
                        </li>
                        <li><strong>Lógicos:</strong> `&&` (AND lógico), `||` (OR lógico), `!` (NOT lógico). Usados para combinar o negar condiciones booleanas.
                            <pre><code class="language-c">
int condicion1 = 1, condicion2 = 0; // 1 es verdadero, 0 es falso en C
printf("AND: %d\n", condicion1 && condicion2); // 0
printf("OR: %d\n", condicion1 || condicion2);  // 1
printf("NOT condicion1: %d\n", !condicion1);  // 0
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Precedencia entre operadores:</strong> El orden en que se evalúan los operadores en una expresión compleja (ej., la multiplicación se evalúa antes que la suma).
                    <pre><code class="language-c">
int resultado = 5 + 2 * 3;  // Primero 2*3=6, luego 5+6=11. resultado = 11
int resultado2 = (5 + 2) * 3; // Primero (5+2)=7, luego 7*3=21. resultado2 = 21
                    </code></pre>
                </li>
                <li><strong>Operadores de asignación:</strong> Usados para asignar un valor a una variable. El más común es `=`, pero también existen operadores combinados como `+=`, `-=`, `*=`, `/=`, `%=`.
                    <pre><code class="language-c">
int contador = 10;
contador += 5; // Equivalente a contador = contador + 5; contador ahora es 15
contador *= 2; // Equivalente a contador = contador * 2; contador ahora es 30
                    </code></pre>
                </li>
                <li><strong>Funciones básicas de entrada/salida:</strong> Interacción con el usuario. `printf()` para imprimir datos en la consola y `scanf()` para leer datos ingresados por el usuario desde el teclado.
                    <pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int numero;
    printf("Por favor, ingrese un número entero: ");
    scanf("%d", &numero); // Lee un entero del teclado y lo guarda en 'numero'
    printf("Usted ingresó: %d\n", numero);
    return 0;
}
                    </code></pre>
                </li>
            </ul>
        </section>

        <section class="unidad">
            <h3>UNIDAD 3 - Sentencias de Control e Iteración</h3>
            <p>Esta unidad es crucial para la lógica de programación. Se aprenderá a controlar el flujo de ejecución de un programa, permitiendo que tome decisiones y repita acciones, lo cual es esencial para resolver problemas complejos.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Composición Secuencial de Acciones:</strong> El flujo de ejecución predeterminado de un programa, donde las instrucciones se ejecutan una tras otra en el orden en que aparecen.</li>
                <li><strong>Estados iniciales y finales:</strong> El valor de las variables y el estado general del programa al comienzo y al final de una sección o bloque de código.</li>
                <li><strong>Estados intermedios y Refinamiento sucesivos:</strong> Cómo el estado del programa cambia paso a paso a medida que se ejecutan las sentencias, y cómo se descompone un problema grande en subproblemas más pequeños y manejables.</li>
                <li><strong>La estructura de decisión:</strong> Permite que un programa elija diferentes caminos de ejecución basados en una condición lógica.</li>
                <li><strong>Estructura de decisión múltiple:</strong> Una forma eficiente de manejar múltiples opciones basadas en el valor de una única expresión.</li>
                <li><strong>Tipos de estructura de Control:</strong>
                    <ul>
                        <li><strong>Sentencia IF-Else:</strong> Una construcción condicional que ejecuta un bloque de código si una condición es verdadera y, opcionalmente, otro bloque si es falsa.
                            <pre><code class="language-c">
int edad = 18;
if (edad >= 18) {
    printf("Es mayor de edad.\n");
} else {
    printf("Es menor de edad.\n");
}
                            </code></pre>
                        </li>
                        <li><strong>Sentencia Switch:</strong> Permite que una variable o expresión sea probada para igualdad contra una lista de valores. Cada valor se llama un caso.
                            <pre><code class="language-c">
char opcion = 'B';
switch (opcion) {
    case 'A':
        printf("Opción A seleccionada.\n");
        break;
    case 'B':
        printf("Opción B seleccionada.\n");
        break;
    default:
        printf("Opción inválida.\n");
        break;
}
                            </code></pre>
                        </li>
                        <li><strong>Sentencias anidadas:</strong> Cuando una sentencia de control (como un `if` o un bucle `for`) está contenida dentro de otra sentencia de control.
                            <pre><code class="language-c">
int nota = 85;
int asistencia = 90;

if (nota >= 60) {
    if (asistencia >= 75) {
        printf("¡Aprobado!\n");
    } else {
        printf("Aprobado con condición de asistencia.\n");
    }
} else {
    printf("Desaprobado.\n");
}
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Principio de Inducción:</strong> Un método de prueba matemática que subyace al funcionamiento de los bucles y la recursividad, demostrando que una propiedad se cumple para todos los elementos de un conjunto si se cumple para el primero y se propaga.</li>
                <li><strong>La estructura de Iteración:</strong> Permite que un bloque de código se ejecute repetidamente hasta que se cumpla una condición de terminación. Conocidos como bucles o ciclos.</li>
                <li><strong>Tipos de estructura de iteración:</strong>
                    <ul>
                        <li><strong>Sentencia While:</strong> Un bucle que ejecuta un bloque de código repetidamente mientras una condición específica sea verdadera. La condición se evalúa antes de cada iteración.
                            <pre><code class="language-c">
int i = 0;
while (i < 5) {
    printf("Contador: %d\n", i);
    i++; // Incrementa i en 1
}
                            </code></pre>
                        </li>
                        <li><strong>Sentencia For:</strong> Un bucle utilizado cuando se conoce el número de iteraciones. Generalmente incluye una inicialización, una condición de continuación y una actualización de la variable de control.
                            <pre><code class="language-c">
for (int i = 0; i < 5; i++) {
    printf("Iteración: %d\n", i);
}
                            </code></pre>
                        </li>
                        <li><strong>Sentencia Do-While:</strong> Similar al `while`, pero garantiza que el bloque de código se ejecute al menos una vez, ya que la condición se evalúa al final de cada iteración.
                            <pre><code class="language-c">
int j = 0;
do {
    printf("Ejecución Do-While: %d\n", j);
    j++;
} while (j < 3); // Se ejecuta al menos una vez, incluso si j fuera 3 inicialmente
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Programación Esquemática:</strong> Un enfoque para diseñar algoritmos y programas utilizando patrones o esquemas comunes de resolución de problemas, lo que facilita la estructuración y comprensión del código.</li>
            </ul>
        </section>

        <section class="unidad">
            <h3>Unidad 4 – Arreglos, Cadenas y Estructuras dinámicas</h3>
            <p>Esta unidad profundiza en la organización de datos, desde colecciones ordenadas hasta estructuras más complejas que permiten una gestión eficiente de la memoria y la información.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Manejo de Estructuras Secuenciales de Datos:</strong> Formas de almacenar y acceder a colecciones de elementos de manera lineal, como listas o secuencias.</li>
                <li><strong>Arreglos unidimensionales y multidimensionales:</strong>
                    <ul>
                        <li><strong>Unidimensionales (Vectores):</strong> Colecciones de elementos del mismo tipo, almacenados contiguamente en memoria y accesibles mediante un índice.
                            <pre><code class="language-c">
int numeros[5] = {10, 20, 30, 40, 50}; // Declaración e inicialización de un arreglo de 5 enteros
printf("El tercer número es: %d\n", numeros[2]); // Acceso al elemento en índice 2 (que es 30)
                            </code></pre>
                        </li>
                        <li><strong>Multidimensionales (Matrices):</strong> Arreglos de arreglos, utilizados para representar tablas o datos con más de una dimensión.
                            <pre><code class="language-c">
int matriz[2][3] = {{1, 2, 3}, {4, 5, 6}}; // Matriz 2x3
printf("Elemento [0][1]: %d\n", matriz[0][1]); // Acceso al elemento en fila 0, columna 1 (que es 2)
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Operaciones con Arreglos:</strong>
                    <ul>
                        <li><strong>Recorrido:</strong> Visitar cada elemento del arreglo, generalmente para procesarlo o imprimirlo.
                            <pre><code class="language-c">
int i;
int arr[] = {1, 2, 3, 4, 5};
int n = sizeof(arr) / sizeof(arr[0]); // Calcula el tamaño del arreglo
for (i = 0; i < n; i++) {
    printf("%d ", arr[i]);
}
printf("\n");
                            </code></pre>
                        </li>
                        <li><strong>Búsqueda:</strong> Encontrar la posición o existencia de un elemento específico dentro del arreglo (ej., búsqueda lineal).</li>
                        <li><strong>Inserción:</strong> Añadir un nuevo elemento en una posición específica del arreglo.</li>
                    </ul>
                </li>
                <li><strong>Cadena de Caracteres:</strong> En C, una cadena es un arreglo de caracteres terminado por el carácter nulo `\0`. Se usan para representar texto.
                    <pre><code class="language-c">
char nombre[20] = "Juan"; // Declaración de una cadena
printf("Hola, %s!\n", nombre);
                    </code></pre>
                </li>
                <li><strong>Operaciones con cadenas:</strong> Funciones de biblioteca estándar para manipular cadenas, como `strcpy` (copiar), `strcat` (concatenar), `strcmp` (comparar), `strlen` (longitud), `strstr` (buscar subcadena).
                    <pre><code class="language-c">
#include &lt;string.h&gt;
char s1[20] = "Hola";
char s2[20] = " Mundo";
strcat(s1, s2); // s1 ahora es "Hola Mundo"
printf("%s\n", s1);
printf("Longitud de s1: %d\n", (int)strlen(s1)); // Longitud
printf("Comparación (Hola vs Hola): %d\n", strcmp("Hola", "Hola")); // 0 (iguales)
                    </code></pre>
                </li>
                <li><strong>Concepto de Estructuras (structs):</strong> Un tipo de dato compuesto definido por el usuario que agrupa variables de diferentes tipos de datos bajo un único nombre, permitiendo representar entidades complejas (ej., un registro de estudiante con nombre, edad, promedio).
                    <pre><code class="language-c">
struct Persona {
    char nombre[50];
    int edad;
    float altura;
};

int main() {
    struct Persona p1; // Declaración de una variable de tipo Persona
    strcpy(p1.nombre, "Ana");
    p1.edad = 25;
    p1.altura = 1.68;
    printf("Nombre: %s, Edad: %d, Altura: %.2f\n", p1.nombre, p1.edad, p1.altura);
    return 0;
}
                    </code></pre>
                </li>
                <li><strong>Asignación Dinámica de Memoria:</strong>
                    <p>La asignación dinámica de memoria permite a los programas solicitar y liberar memoria en tiempo de ejecución, es decir, mientras el programa se está ejecutando. Esto es crucial cuando el tamaño de los datos no se conoce de antemano (por ejemplo, el número de elementos que el usuario va a ingresar).</p>
                    <p>Las funciones principales de la biblioteca `stdlib.h` para la gestión dinámica de memoria son:</p>
                    <ul>
                        <li>`malloc()`: Asigna un bloque de memoria del tamaño especificado en bytes y devuelve un puntero a la primera ubicación de ese bloque. Si falla, devuelve `NULL`.</li>
                        <pre><code class="language-c">
#include &lt;stdlib.h&gt; // Para malloc, free

int *ptr_dinamico;
int cantidad_elementos = 5;
// Asigna memoria para 5 enteros
ptr_dinamico = (int *) malloc(cantidad_elementos * sizeof(int));

if (ptr_dinamico == NULL) {
    printf("Error: No se pudo asignar memoria.\n");
    return 1; // Salir con error
}

// Usar la memoria asignada
for (int i = 0; i < cantidad_elementos; i++) {
    ptr_dinamico[i] = i * 10;
    printf("%d ", ptr_dinamico[i]);
}
printf("\n");
                        </code></pre>
                        <li>`calloc()`: Asigna un bloque de memoria para un número específico de elementos, cada uno de un tamaño dado, e inicializa todos los bits del bloque a cero.</li>
                        <pre><code class="language-c">
#include &lt;stdlib.h&gt;

float *arr_flotantes;
// Asigna memoria para 3 flotantes e inicializa a 0.0
arr_flotantes = (float *) calloc(3, sizeof(float));

if (arr_flotantes == NULL) {
    printf("Error: No se pudo asignar memoria.\n");
    return 1;
}
printf("Primer elemento de calloc (debe ser 0.0): %.1f\n", arr_flotantes[0]);
                        </code></pre>
                        <li>`realloc()`: Cambia el tamaño de un bloque de memoria previamente asignado. Puede expandirlo o reducirlo, y devuelve un puntero al nuevo bloque (que podría ser la misma ubicación o una nueva).</li>
                        <pre><code class="language-c">
#include &lt;stdlib.h&gt;

int *arr_actual;
arr_actual = (int *) malloc(2 * sizeof(int)); // Asigna para 2 enteros
arr_actual[0] = 1; arr_actual[1] = 2;
printf("Original: %d %d\n", arr_actual[0], arr_actual[1]);

// Reasigna para 4 enteros
arr_actual = (int *) realloc(arr_actual, 4 * sizeof(int));
if (arr_actual == NULL) {
    printf("Error: No se pudo reasignar memoria.\n");
    return 1;
}
arr_actual[2] = 3; arr_actual[3] = 4;
printf("Reasignado: %d %d %d %d\n", arr_actual[0], arr_actual[1], arr_actual[2], arr_actual[3]);
                        </code></pre>
                        <li>`free()`: Libera un bloque de memoria previamente asignado dinámicamente, devolviéndolo al sistema. Es crucial para evitar fugas de memoria (memory leaks).</li>
                        <pre><code class="language-c">
// Después de usar ptr_dinamico, calloc_ptr o realloc_ptr
free(ptr_dinamico);
ptr_dinamico = NULL; // Buena práctica para evitar "dangling pointers"
                        </code></pre>
                    </ul>
                </li>
                <li><strong>Procedimientos de Ordenación y Búsqueda Binaria:</strong>
                    <ul>
                        <li><strong>Ordenación:</strong> Algoritmos para organizar los elementos de un arreglo en un orden específico (ascendente o descendente), como el método de burbuja, selección, inserción.</li>
                        <li><strong>Búsqueda Binaria:</strong> Un algoritmo de búsqueda eficiente que funciona en listas o arreglos *ordenados*, dividiendo repetidamente por la mitad la porción de la lista que podría contener el elemento.</li>
                    </ul>
                </li>
                <li><strong>Estructuras Dinámicas:</strong> Estructuras de datos que pueden expandirse o contraerse en tiempo de ejecución, asignando y liberando memoria según sea necesario. Requieren el uso de punteros y asignación dinámica de memoria.</li>
                <li><strong>Listas Enlazadas:</strong>
                    <p>Una lista enlazada es una estructura de datos lineal donde los elementos no se almacenan en ubicaciones de memoria contiguas, a diferencia de los arreglos. Cada elemento (llamado "nodo") contiene no solo los datos, sino también una referencia (un puntero) al siguiente nodo en la secuencia.</p>
                    <p>Esto permite una inserción y eliminación eficiente de elementos en cualquier posición, ya que solo se necesita ajustar los punteros, no desplazar elementos.</p>
                    <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; // Para malloc, free

// Definición de la estructura de un nodo de la lista
struct Nodo {
    int dato;
    struct Nodo *siguiente; // Puntero al siguiente nodo
};

// Función para insertar un nodo al principio de la lista
void insertarPrincipio(struct Nodo **cabeza, int nuevo_dato) {
    // 1. Crear un nuevo nodo dinámicamente
    struct Nodo *nuevo_nodo = (struct Nodo *) malloc(sizeof(struct Nodo));
    if (nuevo_nodo == NULL) {
        printf("Error de asignación de memoria.\n");
        return;
    }

    // 2. Asignar el dato al nuevo nodo
    nuevo_nodo->dato = nuevo_dato;

    // 3. El siguiente del nuevo nodo es la cabeza actual
    nuevo_nodo->siguiente = *cabeza;

    // 4. La cabeza ahora es el nuevo nodo
    *cabeza = nuevo_nodo;
}

// Función para imprimir la lista
void imprimirLista(struct Nodo *nodo) {
    while (nodo != NULL) {
        printf("%d -> ", nodo->dato);
        nodo = nodo->siguiente;
    }
    printf("NULL\n");
}

int main() {
    struct Nodo *cabeza = NULL; // La lista inicialmente está vacía

    insertarPrincipio(&cabeza, 30);
    insertarPrincipio(&cabeza, 20);
    insertarPrincipio(&cabeza, 10); // La lista ahora es 10 -> 20 -> 30 -> NULL

    printf("Lista enlazada: ");
    imprimirLista(cabeza);

    // Liberar la memoria (importante para evitar memory leaks)
    struct Nodo *actual = cabeza;
    struct Nodo *siguiente;
    while (actual != NULL) {
        siguiente = actual->siguiente;
        free(actual);
        actual = siguiente;
    }
    cabeza = NULL; // Buena práctica
    return 0;
}
                    </code></pre>
                </li>
                <li><strong>Pilas (Stack):</strong> Estructura de datos LIFO (Last In, First Out), donde el último elemento añadido es el primero en ser retirado (ej., pila de platos). Operaciones: `push` (añadir), `pop` (quitar).</li>
                <li><strong>Colas (Queue):</strong> Estructura de datos FIFO (First In, First Out), donde el primer elemento añadido es el primero en ser retirado (ej., cola de espera). Operaciones: `enqueue` (añadir), `dequeue` (quitar).</li>
                <li><strong>Árboles binarios:</strong> Una estructura de datos jerárquica no lineal donde cada nodo tiene como máximo dos nodos hijos (izquierdo y derecho). Utilizados para organizar datos de forma eficiente para búsqueda y ordenación.</li>
                <li><strong>Operaciones con estructuras dinámicas: Recorrido, búsqueda, inserción:</strong> Métodos específicos para interactuar con estas estructuras complejas, considerando su naturaleza dinámica.</li>
                <li><strong>Archivos:</strong> Cómo un programa puede interactuar con el sistema de archivos del sistema operativo para leer y escribir datos de forma persistente en el disco duro, permitiendo almacenar información más allá de la ejecución del programa.
                    <pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    FILE *fp;
    // Escritura en un archivo
    fp = fopen("ejemplo.txt", "w"); // "w" para escribir (crea o sobrescribe)
    if (fp == NULL) {
        printf("Error al abrir el archivo para escritura.\n");
        return 1;
    }
    fprintf(fp, "Hola, esto es una línea de texto.\n");
    fprintf(fp, "Esta es otra línea.\n");
    fclose(fp);
    printf("Archivo escrito exitosamente.\n");

    // Lectura de un archivo
    char buffer[100];
    fp = fopen("ejemplo.txt", "r"); // "r" para leer
    if (fp == NULL) {
        printf("Error al abrir el archivo para lectura.\n");
        return 1;
    }
    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
        printf("%s", buffer);
    }
    fclose(fp);
    return 0;
}
                    </code></pre>
                </li>
            </ul>
        </section>

        <section class="unidad">
            <h3>Unidad 5 - Modularidad</h3>
            <p>Esta unidad enseña cómo dividir programas grandes en componentes más pequeños y manejables, lo que mejora la organización del código, su reusabilidad y facilita el trabajo en equipo.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Modularización: Subprogramas, Funciones y Procedimientos:</strong> El concepto de dividir un programa en módulos independientes, cada uno con una tarea específica. En C, esto se logra principalmente con funciones.
                    <ul>
                        <li><strong>Funciones:</strong> Bloques de código que realizan una tarea específica y devuelven un valor.
                            <pre><code class="language-c">
int sumar(int a, int b) { // Función que devuelve un entero
    return a + b;
}

int main() {
    int resultado = sumar(5, 3); // Llamada a la función
    printf("La suma es: %d\n", resultado); // 8
    return 0;
}
                            </code></pre>
                        </li>
                        <li><strong>Procedimientos:</strong> (En C se implementan como funciones `void`) Bloques de código que realizan una tarea pero no devuelven explícitamente un valor.
                            <pre><code class="language-c">
void saludar(char *nombre) { // Función void (no devuelve valor)
    printf("Hola, %s!\n", nombre);
}

int main() {
    saludar("Maria"); // Llamada al procedimiento
    return 0;
}
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Variables locales y Globales:</strong>
                    <ul>
                        <li><strong>Locales:</strong> Declaradas dentro de una función o bloque de código; solo son accesibles dentro de ese ámbito.
                            <pre><code class="language-c">
void funcionLocal() {
    int x = 10; // Variable local a funcionLocal
    printf("Dentro de funcionLocal, x = %d\n", x);
}

int main() {
    // printf("%d", x); // Esto daría error, x no es accesible aquí
    funcionLocal();
    return 0;
}
                            </code></pre>
                        </li>
                        <li><strong>Globales:</strong> Declaradas fuera de cualquier función; accesibles desde cualquier parte del programa. Su uso debe ser cuidadoso.
                            <pre><code class="language-c">
int global_var = 100; // Variable global

void imprimirGlobal() {
    printf("Desde función, global_var = %d\n", global_var);
}

int main() {
    printf("Desde main, global_var = %d\n", global_var);
    imprimirGlobal();
    global_var = 200; // Modifica la variable global
    printf("Desde main (modificada), global_var = %d\n", global_var);
    return 0;
}
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Pasaje de Parámetros:</strong> La forma en que los datos se transfieren de la función que llama a la función llamada.</li>
                <li><strong>Pasajes por valor y por referencia:</strong>
                    <ul>
                        <li><strong>Por valor:</strong> Se pasa una copia del valor de la variable. Cualquier cambio dentro de la función no afecta a la variable original.
                            <pre><code class="language-c">
void modificarPorValor(int num) {
    num = num + 10;
    printf("Dentro de la función (por valor): %d\n", num);
}

int main() {
    int miNumero = 5;
    printf("Antes de la función (por valor): %d\n", miNumero); // 5
    modificarPorValor(miNumero); // Pasa una COPIA de miNumero
    printf("Después de la función (por valor): %d\n", miNumero); // Sigue siendo 5
    return 0;
}
                            </code></pre>
                        </li>
                        <li><strong>Por referencia:</strong> Se pasa la dirección de memoria de la variable. Los cambios dentro de la función afectan directamente a la variable original. (Se usa con punteros en C).
                            <pre><code class="language-c">
void modificarPorReferencia(int *pNum) { // Recibe un puntero a int
    *pNum = *pNum + 10; // Modifica el valor al que apunta el puntero
    printf("Dentro de la función (por referencia): %d\n", *pNum);
}

int main() {
    int miNumero = 5;
    printf("Antes de la función (por referencia): %d\n", miNumero); // 5
    modificarPorReferencia(&miNumero); // Pasa la DIRECCIÓN de miNumero
    printf("Después de la función (por referencia): %d\n", miNumero); // Ahora es 15
    return 0;
}
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Parámetros nominales y efectivos:</strong>
                    <ul>
                        <li><strong>Nominales (o formales):</strong> Los nombres de los parámetros definidos en la declaración o prototipo de la función (ej., `int a, int b` en `int sumar(int a, int b)`).</li>
                        <li><strong>Efectivos (o actuales):</strong> Los valores o variables reales que se pasan a la función cuando esta es invocada (ej., `5, 3` en `sumar(5, 3)`).</li>
                    </ul>
                </li>
                <li><strong>Recursividad:</strong>
                    <p>La recursividad es una técnica de programación poderosa donde una función se llama a sí misma para resolver un problema. Es especialmente útil para problemas que pueden dividirse en subproblemas más pequeños que son de la misma naturaleza que el problema original. Una función recursiva debe tener dos partes fundamentales:</p>
                    <ul>
                        <li><strong>Caso Base:</strong> Una condición que, cuando se cumple, permite a la función devolver un valor sin hacer más llamadas recursivas. Esto es crucial para evitar bucles infinitos.</li>
                        <li><strong>Paso Recursivo:</strong> La parte donde la función se llama a sí misma con argumentos que se acercan al caso base, resolviendo una versión más pequeña del problema.</li>
                    </ul>
                    <p><strong>Ejemplo: Cálculo del factorial de un número.</strong></p>
                    <pre><code class="language-c">
// Ejemplo: Cálculo del factorial de un número usando recursividad
int factorial(int n) {
    // Caso Base: Si n es 0, el factorial es 1
    if (n == 0) {
        return 1;
    } else {
        // Paso Recursivo: n * factorial de (n-1)
        // La función se llama a sí misma con un argumento más pequeño
        return n * factorial(n - 1);
    }
}

int main() {
    int num = 4; // Calcular 4! (4 * 3 * 2 * 1 = 24)
    printf("El factorial de %d es: %d\n", num, factorial(num)); // 24

    int num2 = 0; // Calcular 0! (debe ser 1)
    printf("El factorial de %d es: %d\n", num2, factorial(num2)); // 1
    return 0;
}
                    </code></pre>
                    <p><strong>Pila de Llamadas (Call Stack):</strong> Cada vez que una función recursiva se llama a sí misma, se crea un nuevo "marco" en la pila de llamadas de la memoria. Este marco contiene las variables locales y el punto de retorno de esa llamada específica. Una vez que se alcanza el caso base, las llamadas se empiezan a "desapilar" en orden inverso, resolviendo los resultados intermedios hasta que se devuelve el resultado final a la llamada original.</p>
                </li>
                <li><strong>Modularización de un programa en varios archivos:</strong> Organizar el código de un proyecto grande en múltiples archivos `.c` (con la implementación de funciones) y archivos `.h` (cabeceras, con las declaraciones de funciones y estructuras), para mejorar la organización, compilación y reusabilidad.
                    <pre><code class="language-c">
// --- archivo: funciones.h ---
// Prototipo de la función
int sumar(int a, int b);
void saludar(char *nombre);

// --- archivo: funciones.c ---
#include "funciones.h" // Incluye el archivo de cabecera
#include &lt;stdio.h&gt; // Necesario para printf en esta función

int sumar(int a, int b) {
    return a + b;
}

void saludar(char *nombre) {
    printf("Hola, %s desde funciones.c!\n", nombre);
}

// --- archivo: main.c ---
#include &lt;stdio.h&gt;
#include "funciones.h" // Incluye la cabecera de nuestras funciones

int main() {
    int resultado = sumar(10, 5);
    printf("Resultado de la suma: %d\n", resultado);
    saludar("Carlos");
    return 0;
}
// Para compilar: gcc main.c funciones.c -o programa
// Se compilan todos los archivos .c juntos.
                    </code></pre>
                </li>
            </ul>
        </section>

        <section class="unidad">
            <h3>UNIDAD 6 – Programación Orientada a Objeto (POO)</h3>
            <p>Esta unidad introduce un paradigma de programación fundamental en la industria actual, que permite diseñar software de manera más intuitiva, organizada y escalable, simulando entidades del mundo real.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Concepto de Programación orientada a objetos (POO):</strong> Un paradigma de programación que utiliza "objetos" como bloques fundamentales. Los objetos combinan datos (atributos) y el comportamiento (métodos) que opera sobre esos datos.
                    <p>Aunque C no es un lenguaje POO nativo, se pueden simular muchos de sus conceptos clave utilizando las herramientas disponibles en C, como estructuras y punteros a funciones. Esto requiere una comprensión más profunda de cómo se organizan los datos y el comportamiento de manera modular.</p>
                </li>
                <li><strong>Diferencia entre programación estructurada y programación orientada a objetos:</strong>
                    <ul>
                        <li><strong>Estructurada:</strong> Se enfoca en procedimientos (funciones) que operan sobre datos separados. El foco está en el "cómo" se realiza el proceso.</li>
                        <li><strong>POO:</strong> Se enfoca en objetos que agrupan datos y los métodos que los manipulan, promoviendo la cohesión. El foco está en "qué" entidades existen y cómo interactúan.</li>
                    </ul>
                </li>
                <li><strong>Beneficios de la aplicación de la programación orientada a objetos:</strong>
                    <ul>
                        <li><strong>Reusabilidad:</strong> El código de los objetos puede ser reutilizado en diferentes partes de un programa o en programas distintos.</li>
                        <li><strong>Mantenibilidad:</strong> El código es más fácil de depurar, modificar y mantener debido a su organización modular y la encapsulación.</li>
                        <li><strong>Escalabilidad:</strong> Facilita el crecimiento y la adición de nuevas funcionalidades sin afectar significativamente el código existente.</li>
                        <li><strong>Legibilidad:</strong> El código es más comprensible al reflejar entidades del mundo real, haciendo el diseño más intuitivo.</li>
                    </ul>
                </li>
                <li><strong>Principios de la programación orientada a objetos (Simulación en C):</strong>
                    <ul>
                        <li><strong>Encapsulamiento:</strong>
                            <p>Se refiere a la agrupación de datos (atributos) y las funciones (métodos) que operan sobre esos datos en una única unidad (el "objeto" o, en C, una estructura junto con funciones que la manipulan). Su objetivo es ocultar los detalles internos de implementación de un objeto, exponiendo solo una interfaz controlada.</p>
                            <p>En C, se simula con `struct` para los datos y un conjunto de funciones que toman punteros a esa `struct` como argumento, operando solo a través de esas funciones para mantener la integridad de los datos.</p>
                            <pre><code class="language-c">
// Simulación de encapsulamiento en C con un struct y funciones "públicas"
typedef struct {
    char nombre[50];
    int edad; // Considerado como un atributo privado o protegido
} Persona;

// Función para inicializar (actúa como un constructor)
void inicializar_persona(Persona *p, const char *nom, int ed) {
    if (p != NULL) {
        strcpy(p->nombre, nom);
        if (ed > 0) { // Validación simple para encapsular la lógica de edad
            p->edad = ed;
        } else {
            p->edad = 0;
            printf("Advertencia: Edad inválida, se estableció en 0.\n");
        }
    }
}

// Función para obtener la edad (actúa como un "getter")
int obtener_edad(const Persona *p) {
    return (p != NULL) ? p->edad : -1; // Retorna -1 si el puntero es NULL
}

// Función para mostrar datos (actúa como un método público)
void mostrar_persona(const Persona *p) {
    if (p != NULL) {
        printf("Nombre: %s, Edad: %d\n", p->nombre, p->edad);
    }
}

/*
int main() {
    Persona p1;
    inicializar_persona(&p1, "Ana", 25);
    mostrar_persona(&p1); // Acceso controlado a los datos
    printf("La edad de Ana es: %d\n", obtener_edad(&p1));

    Persona p2;
    inicializar_persona(&p2, "Luis", -5); // Ejemplo de validación
    mostrar_persona(&p2);
    return 0;
}
*/
                            </code></pre>
                        </li>
                        <li><strong>Herencia:</strong>
                            <p>Permite que una clase (clase hija o subclase) adquiera propiedades y comportamientos (atributos y métodos) de otra clase (clase padre o superclase). Promueve la reutilización de código y establece relaciones "es un tipo de" (e.g., un "Coche" *es un tipo de* "Vehículo").</p>
                            <p>En C, la herencia se simula anidando una estructura dentro de otra. Esto permite a la estructura "hija" contener todos los miembros de la estructura "padre", pero la relación de comportamiento (métodos) y polimorfismo es mucho más compleja de manejar manualmente.</p>
                            <pre><code class="language-c">
// Simulación de Herencia en C
struct Vehiculo {
    int velocidad_max;
    char color[20];
};

struct Coche {
    struct Vehiculo base; // La estructura "padre" anidada
    int num_puertas;
};

/*
int main() {
    struct Coche mi_coche;
    mi_coche.base.velocidad_max = 200; // Acceso a miembros heredados
    strcpy(mi_coche.base.color, "Rojo");
    mi_coche.num_puertas = 4;

    printf("Coche color %s, velocidad max: %d, puertas: %d\n",
           mi_coche.base.color, mi_coche.base.velocidad_max, mi_coche.num_puertas);
    return 0;
}
*/
                            </code></pre>
                        </li>
                        <li><strong>Polimorfismo:</strong>
                            <p>Significa "muchas formas". Permite que objetos de diferentes clases puedan ser tratados como objetos de una clase común, y que un mismo método pueda comportarse de manera diferente en distintas clases. Esto facilita la escritura de código más genérico y flexible.</p>
                            <p>En C, el polimorfismo se simula de forma más manual y compleja, a menudo utilizando punteros a funciones. Se puede crear una tabla de funciones (similar a una "tabla de métodos virtuales") dentro de una estructura, y luego asignar diferentes implementaciones de función a esos punteros para cada "tipo" de objeto.</p>
                            <pre><code class="language-c">
// Simulación de Polimorfismo en C usando punteros a funciones
typedef struct {
    void (*saludar)(void *); // Puntero a función "saludar"
    void (*mostrar_info)(void *); // Puntero a función "mostrar_info"
} InterfazComun;

typedef struct {
    InterfazComun *vtable; // "Tabla de funciones virtuales"
    char nombre[50];
} Gato;

typedef struct {
    InterfazComun *vtable;
    char nombre[50];
    char raza[50];
} Perro;

void saludar_gato(void *animal) {
    Gato *g = (Gato *)animal;
    printf("Miau, soy %s!\n", g->nombre);
}

void mostrar_info_gato(void *animal) {
    Gato *g = (Gato *)animal;
    printf("Gato: %s\n", g->nombre);
}

void saludar_perro(void *animal) {
    Perro *p = (Perro *)animal;
    printf("Guau, soy %s!\n", p->nombre);
}

void mostrar_info_perro(void *animal) {
    Perro *p = (Perro *)animal;
    printf("Perro: %s, Raza: %s\n", p->nombre, p->raza);
}

// Implementaciones de las vtables para cada "clase"
InterfazComun Gato_vtable = {saludar_gato, mostrar_info_gato};
InterfazComun Perro_vtable = {saludar_perro, mostrar_info_perro};

/*
int main() {
    Gato mi_gato = {&Gato_vtable, "Minino"};
    Perro mi_perro = {&Perro_vtable, "Fido", "Golden"};

    // Tratamos a ambos como un tipo común a través de sus vtables
    mi_gato.vtable->saludar(&mi_gato);
    mi_perro.vtable->saludar(&mi_perro);

    mi_gato.vtable->mostrar_info(&mi_gato);
    mi_perro.vtable->mostrar_info(&mi_perro);
    return 0;
}
*/
                            </code></pre>
                        </li>
                        <li><strong>Abstracción:</strong>
                            <p>Consiste en enfocarse en los aspectos esenciales de un objeto o sistema, ocultando los detalles irrelevantes o de implementación. Se trata de crear modelos simplificados del mundo real.</p>
                            <p>En C, se logra principalmente a través de los archivos de cabecera (`.h`). Un archivo `.h` declara las funciones (la interfaz pública) y las estructuras opacas (para ocultar los detalles de implementación de los datos), mientras que el archivo `.c` correspondiente contiene la implementación detallada.</p>
                            <pre><code class="language-c">
// --- archivo: Animal.h (Abstracción de la interfaz) ---
// Declaración de una estructura opaca (detalles ocultos)
typedef struct Animal Animal;

// Prototipos de funciones que operan sobre Animal (la interfaz)
Animal* crear_animal(const char *nombre);
void hacer_sonido(Animal *a);
void liberar_animal(Animal *a);

// --- archivo: Animal.c (Implementación, detalles ocultos) ---
#include "Animal.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// Definición completa de la estructura Animal (detalle de implementación)
struct Animal {
    char nombre[50];
    // Otros atributos y posibles punteros a funciones específicas
};

Animal* crear_animal(const char *nombre) {
    Animal *nuevo_animal = (Animal *) malloc(sizeof(Animal));
    if (nuevo_animal != NULL) {
        strcpy(nuevo_animal->nombre, nombre);
    }
    return nuevo_animal;
}

void hacer_sonido(Animal *a) {
    if (a != NULL) {
        printf("%s hace un sonido.\n", a->nombre);
    }
}

void liberar_animal(Animal *a) {
    free(a);
}

// --- archivo: main.c (Uso de la abstracción) ---
#include "Animal.h"
// El main.c no necesita saber cómo está implementado Animal, solo cómo usarlo.
/*
int main() {
    Animal *mi_animal = crear_animal("Leo");
    if (mi_animal != NULL) {
        hacer_sonido(mi_animal); // Llamada a la interfaz abstracta
        liberar_animal(mi_animal);
    }
    return 0;
}
*/
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Métodos con el mismo indicador y distinto número de parámetros:</strong> Esto se refiere a la **Sobrecarga de Métodos** (un tipo de polimorfismo estático), donde una clase puede tener múltiples métodos con el mismo nombre, pero que se diferencian por la cantidad o el tipo de sus parámetros. (No es una característica directa de C, pero se puede simular con nombres de funciones diferentes o macros).</li>
                <li><strong>Métodos Estáticos:</strong> Métodos que pertenecen a la clase misma, no a una instancia específica (objeto) de la clase. Se invocan directamente desde la clase y no pueden acceder a los atributos de instancia del objeto. (En C, esto serían funciones globales que operan sobre tipos de datos, sin requerir una instancia).</li>
                <li><strong>Recursividad de Métodos:</strong> Aplicación del concepto de recursividad (una función llamándose a sí misma) pero en el contexto de un método dentro de una clase, cuando la resolución del problema se presta a este enfoque.</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Tecnicatura Universitaria en Programación</p>
    </footer>
</body>
</html>
