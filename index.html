<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Material de Estudio: Algoritmia y Programación en C</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Material de Estudio</h1>
        <h2>Algoritmia y Programación en Lenguaje C</h2>
        <p>Tecnicatura Universitaria en Programación</p>
    </header>

    <main>
        <section class="unidad">
            <h3>UNIDAD 1 – Introducción a la Algoritmia y al Lenguaje C</h3>
            <p>Esta unidad sienta las bases para comprender cómo las computadoras resuelven problemas. Se explora la lógica detrás de cada acción que una máquina ejecuta, desde la idea abstracta hasta su implementación.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Definición de Proceso:</strong> Un proceso se entiende como una secuencia de pasos o actividades interrelacionadas, diseñadas para lograr un objetivo específico. En computación, a menudo implica la transformación de datos.</li>
                <li><strong>Acciones y Estados:</strong> Las acciones son las operaciones que se realizan, mientras que los estados representan la situación o el valor de los datos en un momento dado antes o después de una acción. Las acciones cambian los estados.</li>
                <li><strong>Representación de Estados:</strong> Cómo se modela y se visualiza la información y las variables en diferentes momentos durante la ejecución de un algoritmo o programa.</li>
                <li><strong>Variables y Constantes:</strong> Son los pilares del almacenamiento de datos. Las <strong>variables</strong> son espacios de memoria con un nombre que pueden cambiar su valor durante la ejecución del programa (ej., la edad de una persona). Las <strong>constantes</strong> son espacios de memoria cuyo valor permanece fijo e inalterable durante toda la ejecución (ej., el valor de PI).</li>
                <li><strong>Definición de Algoritmo:</strong> Un algoritmo es un conjunto finito y ordenado de instrucciones o reglas bien definidas, no ambiguas y precisas, que permiten resolver un problema, realizar un cómputo o procesar datos. Debe ser finito, preciso, definido y efectivo.</li>
                <li><strong>Definición de Programa:</strong> Un programa es la materialización de un algoritmo. Es una secuencia de instrucciones escritas en un lenguaje de programación específico que una computadora puede interpretar y ejecutar para realizar una tarea determinada.</li>
                <li><strong>Lenguajes y Paradigmas:</strong> Un lenguaje de programación es un sistema de notación para escribir programas. Los paradigmas de programación son estilos fundamentales de programación, que definen cómo se conciben y estructuran los programas (ej., imperativo, declarativo, orientado a objetos).</li>
                <li><strong>Tipos de Paradigmas de Programación:</strong> Se abordarán paradigmas como:
                    <ul>
                        <li><strong>Imperativo:</strong> Se centra en "cómo" hacer algo, mediante secuencias de instrucciones que cambian el estado del programa (ej., C, Fortran).</li>
                        <li><strong>Funcional:</strong> Se centra en "qué" hacer, tratando la computación como la evaluación de funciones matemáticas, evitando el cambio de estado y los datos mutables.</li>
                        <li><strong>Orientado a Objetos (POO):</strong> Organiza el diseño del software alrededor de objetos y sus interacciones, que encapsulan datos y comportamientos (ej., C++, Java).</li>
                    </ul>
                </li>
                <li><strong>Buenas prácticas de programación:</strong> Conjunto de convenciones y técnicas recomendadas para escribir código que sea legible, mantenible, eficiente, robusto y escalable. Incluye el uso de comentarios, nombres significativos, indentación adecuada, etc.</li>
                <li><strong>Estructura de un programa en C:</strong> Se estudiarán los elementos básicos de un programa en C, incluyendo la función `main()` (punto de entrada del programa), la inclusión de bibliotecas (`#include`), las declaraciones de variables y las sentencias.
                    <pre><code class="language-c">
#include &lt;stdio.h&gt; // Incluye la biblioteca estándar de entrada/salida

int main() { // Punto de entrada del programa
    // Esto es un comentario de una sola línea
    /*
     * Esto es un
     * comentario de
     * múltiples líneas
     */
    printf("¡Hola, mundo!\n"); // Muestra un mensaje en la consola
    return 0; // Indica que el programa finalizó correctamente
}
                    </code></pre>
                </li>
                <li><strong>Operaciones básicas de salida:</strong> Cómo un programa puede interactuar con el usuario mostrando información en la consola, principalmente utilizando la función `printf()` para imprimir texto, variables y resultados.
                    <pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int edad = 30;
    float altura = 1.75;
    char inicial = 'J';

    printf("Mi edad es: %d años.\n", edad);
    printf("Mi altura es: %.2f metros.\n", altura);
    printf("Mi inicial es: %c.\n", inicial);
    return 0;
}
                    </code></pre>
                </li>
            </ul>
        </section>

        <section class="unidad">
            <h3>Unidad 2 - Estructura de Datos</h3>
            <p>Esta unidad se centra en cómo la información se almacena y se organiza dentro de la memoria de la computadora. Entenderemos los diferentes tipos de datos y cómo se manipulan a través de operadores.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Tipos de Datos:</strong> Clasificación que define el tipo de valores que una variable o constante puede contener y las operaciones que se pueden realizar con ellos (ej., números, caracteres, booleanos).</li>
                <li><strong>Tipos Primitivos de Datos:</strong> Son los tipos de datos fundamentales y predefinidos en un lenguaje de programación, como `int` (enteros), `float` (números de punto flotante), `char` (caracteres).</li>
                <li><strong>Dominio de cada Tipo:</strong> El rango de valores que un tipo de dato específico puede almacenar. Por ejemplo, un `int` puede almacenar números enteros dentro de un cierto rango definido por el sistema.</li>
                <li><strong>Operaciones válidas:</strong> Las acciones permitidas sobre un tipo de dato, como suma para números, concatenación para cadenas, etc.</li>
                <li><strong>Ocupación de Memoria:</strong> La cantidad de bytes que cada tipo de dato requiere para ser almacenado en la memoria RAM de la computadora.</li>
                <li><strong>Datos Compuestos:</strong> Tipos de datos creados a partir de la combinación de tipos primitivos o de otros tipos compuestos (ej., estructuras, arrays).</li>
                <li><strong>Estructuras de Datos:</strong> Maneras específicas de organizar los datos en la memoria para que puedan ser utilizados de manera eficiente. No son los datos en sí, sino la forma de relacionarlos y acceder a ellos.</li>
                <li><strong>Estructuras estáticas y dinámicas:</strong>
                    <ul>
                        <li><strong>Estáticas:</strong> Su tamaño se define en tiempo de compilación y no puede cambiar durante la ejecución (ej., arrays tradicionales).</li>
                        <li><strong>Dinámicas:</strong> Su tamaño puede crecer o decrecer en tiempo de ejecución, utilizando la asignación dinámica de memoria (ej., listas enlazadas).</li>
                    </ul>
                </li>
                <li><strong>Tipos de Datos: Constantes, variables:</strong> Reafirmación y profundización en la declaración y uso de valores fijos (constantes) y modificables (variables) en el contexto de C.
                    <pre><code class="language-c">
const float PI = 3.14159; // Declaración de una constante
int radio = 5;            // Declaración de una variable
float area;

area = PI * radio * radio; // Asignación de un valor a la variable 'area'
printf("El área del círculo es: %.2f\n", area);

// PI = 3.0; // Esto daría un error, PI es una constante
radio = 7; // Esto es válido, radio es una variable
                    </code></pre>
                </li>
                <li><strong>Operadores matemáticos, relacionales y lógicos:</strong>
                    <ul>
                        <li><strong>Matemáticos:</strong> `+` (suma), `-` (resta), `*` (multiplicación), `/` (división), `%` (módulo).
                            <pre><code class="language-c">
int a = 10, b = 3;
printf("Suma: %d\n", a + b);     // 13
printf("Resta: %d\n", a - b);    // 7
printf("Multiplicación: %d\n", a * b); // 30
printf("División (entera): %d\n", a / b); // 3
printf("Módulo: %d\n", a % b);   // 1 (resto de la división)
                            </code></pre>
                        </li>
                        <li><strong>Relacionales:</strong> `==` (igual a), `!=` (diferente de), `<` (menor que), `>` (mayor que), `<=` (menor o igual que), `>=` (mayor o igual que). Usados para comparar valores.
                            <pre><code class="language-c">
int x = 5, y = 8;
printf("x == y: %d\n", x == y); // 0 (falso)
printf("x < y: %d\n", x < y);   // 1 (verdadero)
                            </code></pre>
                        </li>
                        <li><strong>Lógicos:</strong> `&&` (AND lógico), `||` (OR lógico), `!` (NOT lógico). Usados para combinar o negar condiciones booleanas.
                            <pre><code class="language-c">
int condicion1 = 1, condicion2 = 0; // 1 es verdadero, 0 es falso en C
printf("AND: %d\n", condicion1 && condicion2); // 0
printf("OR: %d\n", condicion1 || condicion2);  // 1
printf("NOT condicion1: %d\n", !condicion1);  // 0
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Precedencia entre operadores:</strong> El orden en que se evalúan los operadores en una expresión compleja (ej., la multiplicación se evalúa antes que la suma).
                    <pre><code class="language-c">
int resultado = 5 + 2 * 3;  // Primero 2*3=6, luego 5+6=11. resultado = 11
int resultado2 = (5 + 2) * 3; // Primero (5+2)=7, luego 7*3=21. resultado2 = 21
                    </code></pre>
                </li>
                <li><strong>Operadores de asignación:</strong> Usados para asignar un valor a una variable. El más común es `=`, pero también existen operadores combinados como `+=`, `-=`, `*=`, `/=`, `%=`.
                    <pre><code class="language-c">
int contador = 10;
contador += 5; // Equivalente a contador = contador + 5; contador ahora es 15
contador *= 2; // Equivalente a contador = contador * 2; contador ahora es 30
                    </code></pre>
                </li>
                <li><strong>Funciones básicas de entrada/salida:</strong> Interacción con el usuario. `printf()` para imprimir datos en la consola y `scanf()` para leer datos ingresados por el usuario desde el teclado.
                    <pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int numero;
    printf("Por favor, ingrese un número entero: ");
    scanf("%d", &numero); // Lee un entero del teclado y lo guarda en 'numero'
    printf("Usted ingresó: %d\n", numero);
    return 0;
}
                    </code></pre>
                </li>
            </ul>
        </section>

        <section class="unidad">
            <h3>UNIDAD 3 - Sentencias de Control e Iteración</h3>
            <p>Esta unidad es crucial para la lógica de programación. Se aprenderá a controlar el flujo de ejecución de un programa, permitiendo que tome decisiones y repita acciones, lo cual es esencial para resolver problemas complejos.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Composición Secuencial de Acciones:</strong> El flujo de ejecución predeterminado de un programa, donde las instrucciones se ejecutan una tras otra en el orden en que aparecen.</li>
                <li><strong>Estados iniciales y finales:</strong> El valor de las variables y el estado general del programa al comienzo y al final de una sección o bloque de código.</li>
                <li><strong>Estados intermedios y Refinamiento sucesivos:</strong> Cómo el estado del programa cambia paso a paso a medida que se ejecutan las sentencias, y cómo se descompone un problema grande en subproblemas más pequeños y manejables.</li>
                <li><strong>La estructura de decisión:</strong> Permite que un programa elija diferentes caminos de ejecución basados en una condición lógica.</li>
                <li><strong>Estructura de decisión múltiple:</strong> Una forma eficiente de manejar múltiples opciones basadas en el valor de una única expresión.</li>
                <li><strong>Tipos de estructura de Control:</strong>
                    <ul>
                        <li><strong>Sentencia IF-Else:</strong> Una construcción condicional que ejecuta un bloque de código si una condición es verdadera y, opcionalmente, otro bloque si es falsa.
                            <pre><code class="language-c">
int edad = 18;
if (edad >= 18) {
    printf("Es mayor de edad.\n");
} else {
    printf("Es menor de edad.\n");
}
                            </code></pre>
                        </li>
                        <li><strong>Sentencia Switch:</strong> Permite que una variable o expresión sea probada para igualdad contra una lista de valores. Cada valor se llama un caso.
                            <pre><code class="language-c">
char opcion = 'B';
switch (opcion) {
    case 'A':
        printf("Opción A seleccionada.\n");
        break;
    case 'B':
        printf("Opción B seleccionada.\n");
        break;
    default:
        printf("Opción inválida.\n");
        break;
}
                            </code></pre>
                        </li>
                        <li><strong>Sentencias anidadas:</strong> Cuando una sentencia de control (como un `if` o un bucle `for`) está contenida dentro de otra sentencia de control.
                            <pre><code class="language-c">
int nota = 85;
int asistencia = 90;

if (nota >= 60) {
    if (asistencia >= 75) {
        printf("¡Aprobado!\n");
    } else {
        printf("Aprobado con condición de asistencia.\n");
    }
} else {
    printf("Desaprobado.\n");
}
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Principio de Inducción:</strong> Un método de prueba matemática que subyace al funcionamiento de los bucles y la recursividad, demostrando que una propiedad se cumple para todos los elementos de un conjunto si se cumple para el primero y se propaga.</li>
                <li><strong>La estructura de Iteración:</strong> Permite que un bloque de código se ejecute repetidamente hasta que se cumpla una condición de terminación. Conocidos como bucles o ciclos.</li>
                <li><strong>Tipos de estructura de iteración:</strong>
                    <ul>
                        <li><strong>Sentencia While:</strong> Un bucle que ejecuta un bloque de código repetidamente mientras una condición específica sea verdadera. La condición se evalúa antes de cada iteración.
                            <pre><code class="language-c">
int i = 0;
while (i < 5) {
    printf("Contador: %d\n", i);
    i++; // Incrementa i en 1
}
                            </code></pre>
                        </li>
                        <li><strong>Sentencia For:</strong> Un bucle utilizado cuando se conoce el número de iteraciones. Generalmente incluye una inicialización, una condición de continuación y una actualización de la variable de control.
                            <pre><code class="language-c">
for (int i = 0; i < 5; i++) {
    printf("Iteración: %d\n", i);
}
                            </code></pre>
                        </li>
                        <li><strong>Sentencia Do-While:</strong> Similar al `while`, pero garantiza que el bloque de código se ejecute al menos una vez, ya que la condición se evalúa al final de cada iteración.
                            <pre><code class="language-c">
int j = 0;
do {
    printf("Ejecución Do-While: %d\n", j);
    j++;
} while (j < 3); // Se ejecuta al menos una vez, incluso si j fuera 3 inicialmente
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Programación Esquemática:</strong> Un enfoque para diseñar algoritmos y programas utilizando patrones o esquemas comunes de resolución de problemas, lo que facilita la estructuración y comprensión del código.</li>
            </ul>
        </section>

        <section class="unidad">
            <h3>Unidad 4 – Arreglos, Cadenas y Estructuras dinámicas</h3>
            <p>Esta unidad profundiza en la organización de datos, desde colecciones ordenadas hasta estructuras más complejas que permiten una gestión eficiente de la memoria y la información.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Manejo de Estructuras Secuenciales de Datos:</strong> Formas de almacenar y acceder a colecciones de elementos de manera lineal, como listas o secuencias.</li>
                <li><strong>Arreglos unidimensionales y multidimensionales:</strong>
                    <ul>
                        <li><strong>Unidimensionales (Vectores):</strong> Colecciones de elementos del mismo tipo, almacenados contiguamente en memoria y accesibles mediante un índice.
                            <pre><code class="language-c">
int numeros[5] = {10, 20, 30, 40, 50}; // Declaración e inicialización de un arreglo de 5 enteros
printf("El tercer número es: %d\n", numeros[2]); // Acceso al elemento en índice 2 (que es 30)
                            </code></pre>
                        </li>
                        <li><strong>Multidimensionales (Matrices):</strong> Arreglos de arreglos, utilizados para representar tablas o datos con más de una dimensión.
                            <pre><code class="language-c">
int matriz[2][3] = {{1, 2, 3}, {4, 5, 6}}; // Matriz 2x3
printf("Elemento [0][1]: %d\n", matriz[0][1]); // Acceso al elemento en fila 0, columna 1 (que es 2)
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Operaciones con Arreglos:</strong>
                    <ul>
                        <li><strong>Recorrido:</strong> Visitar cada elemento del arreglo, generalmente para procesarlo o imprimirlo.
                            <pre><code class="language-c">
int i;
int arr[] = {1, 2, 3, 4, 5};
int n = sizeof(arr) / sizeof(arr[0]); // Calcula el tamaño del arreglo
for (i = 0; i < n; i++) {
    printf("%d ", arr[i]);
}
printf("\n");
                            </code></pre>
                        </li>
                        <li><strong>Búsqueda:</strong> Encontrar la posición o existencia de un elemento específico dentro del arreglo (ej., búsqueda lineal).</li>
                        <li><strong>Inserción:</strong> Añadir un nuevo elemento en una posición específica del arreglo.</li>
                    </ul>
                </li>
                <li><strong>Cadena de Caracteres:</strong> En C, una cadena es un arreglo de caracteres terminado por el carácter nulo `\0`. Se usan para representar texto.
                    <pre><code class="language-c">
char nombre[20] = "Juan"; // Declaración de una cadena
printf("Hola, %s!\n", nombre);
                    </code></pre>
                </li>
                <li><strong>Operaciones con cadenas:</strong> Funciones de biblioteca estándar para manipular cadenas, como `strcpy` (copiar), `strcat` (concatenar), `strcmp` (comparar), `strlen` (longitud), `strstr` (buscar subcadena).
                    <pre><code class="language-c">
#include &lt;string.h&gt;
char s1[20] = "Hola";
char s2[20] = " Mundo";
strcat(s1, s2); // s1 ahora es "Hola Mundo"
printf("%s\n", s1);
printf("Longitud de s1: %d\n", (int)strlen(s1)); // Longitud
printf("Comparación (Hola vs Hola): %d\n", strcmp("Hola", "Hola")); // 0 (iguales)
                    </code></pre>
                </li>
                <li><strong>Concepto de Estructuras (structs):</strong> Un tipo de dato compuesto definido por el usuario que agrupa variables de diferentes tipos de datos bajo un único nombre, permitiendo representar entidades complejas (ej., un registro de estudiante con nombre, edad, promedio).
                    <pre><code class="language-c">
struct Persona {
    char nombre[50];
    int edad;
    float altura;
};

int main() {
    struct Persona p1; // Declaración de una variable de tipo Persona
    strcpy(p1.nombre, "Ana");
    p1.edad = 25;
    p1.altura = 1.68;
    printf("Nombre: %s, Edad: %d, Altura: %.2f\n", p1.nombre, p1.edad, p1.altura);
    return 0;
}
                    </code></pre>
                </li>
                <li><strong>Procedimientos de Ordenación y Búsqueda Binaria:</strong>
                    <ul>
                        <li><strong>Ordenación:</strong> Algoritmos para organizar los elementos de un arreglo en un orden específico (ascendente o descendente), como el método de burbuja, selección, inserción.</li>
                        <li><strong>Búsqueda Binaria:</strong> Un algoritmo de búsqueda eficiente que funciona en listas o arreglos *ordenados*, dividiendo repetidamente por la mitad la porción de la lista que podría contener el elemento.</li>
                    </ul>
                </li>
                <li><strong>Estructuras Dinámicas:</strong> Estructuras de datos que pueden expandirse o contraerse en tiempo de ejecución, asignando y liberando memoria según sea necesario. Requieren el uso de punteros.</li>
                <li><strong>Listas, Pilas y Colas:</strong>
                    <ul>
                        <li><strong>Listas (enlazadas):</strong> Colecciones de nodos donde cada nodo contiene un dato y una referencia al siguiente nodo, permitiendo una inserción y eliminación flexible.</li>
                        <li><strong>Pilas (Stack):</strong> Estructura de datos LIFO (Last In, First Out), donde el último elemento añadido es el primero en ser retirado (ej., pila de platos). Operaciones: `push` (añadir), `pop` (quitar).</li>
                        <li><strong>Colas (Queue):</strong> Estructura de datos FIFO (First In, First Out), donde el primer elemento añadido es el primero en ser retirado (ej., cola de espera). Operaciones: `enqueue` (añadir), `dequeue` (quitar).</li>
                    </ul>
                </li>
                <li><strong>Árboles binarios:</strong> Una estructura de datos jerárquica no lineal donde cada nodo tiene como máximo dos nodos hijos (izquierdo y derecho). Utilizados para organizar datos de forma eficiente para búsqueda y ordenación.</li>
                <li><strong>Operaciones con estructuras dinámicas: Recorrido, búsqueda, inserción:</strong> Métodos específicos para interactuar con estas estructuras complejas, considerando su naturaleza dinámica.</li>
                <li><strong>Archivos:</strong> Cómo un programa puede interactuar con el sistema de archivos del sistema operativo para leer y escribir datos de forma persistente en el disco duro, permitiendo almacenar información más allá de la ejecución del programa.
                    <pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    FILE *fp;
    // Escritura en un archivo
    fp = fopen("ejemplo.txt", "w"); // "w" para escribir (crea o sobrescribe)
    if (fp == NULL) {
        printf("Error al abrir el archivo para escritura.\n");
        return 1;
    }
    fprintf(fp, "Hola, esto es una línea de texto.\n");
    fprintf(fp, "Esta es otra línea.\n");
    fclose(fp);
    printf("Archivo escrito exitosamente.\n");

    // Lectura de un archivo
    char buffer[100];
    fp = fopen("ejemplo.txt", "r"); // "r" para leer
    if (fp == NULL) {
        printf("Error al abrir el archivo para lectura.\n");
        return 1;
    }
    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
        printf("%s", buffer);
    }
    fclose(fp);
    return 0;
}
                    </code></pre>
                </li>
            </ul>
        </section>

        <section class="unidad">
            <h3>Unidad 5 - Modularidad</h3>
            <p>Esta unidad enseña cómo dividir programas grandes en componentes más pequeños y manejables, lo que mejora la organización del código, su reusabilidad y facilita el trabajo en equipo.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Modularización: Subprogramas, Funciones y Procedimientos:</strong> El concepto de dividir un programa en módulos independientes, cada uno con una tarea específica. En C, esto se logra principalmente con funciones.
                    <ul>
                        <li><strong>Funciones:</strong> Bloques de código que realizan una tarea específica y devuelven un valor.
                            <pre><code class="language-c">
int sumar(int a, int b) { // Función que devuelve un entero
    return a + b;
}

int main() {
    int resultado = sumar(5, 3); // Llamada a la función
    printf("La suma es: %d\n", resultado); // 8
    return 0;
}
                            </code></pre>
                        </li>
                        <li><strong>Procedimientos:</strong> (En C se implementan como funciones `void`) Bloques de código que realizan una tarea pero no devuelven explícitamente un valor.
                            <pre><code class="language-c">
void saludar(char *nombre) { // Función void (no devuelve valor)
    printf("Hola, %s!\n", nombre);
}

int main() {
    saludar("Maria"); // Llamada al procedimiento
    return 0;
}
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Variables locales y Globales:</strong>
                    <ul>
                        <li><strong>Locales:</strong> Declaradas dentro de una función o bloque de código; solo son accesibles dentro de ese ámbito.
                            <pre><code class="language-c">
void funcionLocal() {
    int x = 10; // Variable local a funcionLocal
    printf("Dentro de funcionLocal, x = %d\n", x);
}

int main() {
    // printf("%d", x); // Esto daría error, x no es accesible aquí
    funcionLocal();
    return 0;
}
                            </code></pre>
                        </li>
                        <li><strong>Globales:</strong> Declaradas fuera de cualquier función; accesibles desde cualquier parte del programa. Su uso debe ser cuidadoso.
                            <pre><code class="language-c">
int global_var = 100; // Variable global

void imprimirGlobal() {
    printf("Desde función, global_var = %d\n", global_var);
}

int main() {
    printf("Desde main, global_var = %d\n", global_var);
    imprimirGlobal();
    global_var = 200; // Modifica la variable global
    printf("Desde main (modificada), global_var = %d\n", global_var);
    return 0;
}
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Pasaje de Parámetros:</strong> La forma en que los datos se transfieren de la función que llama a la función llamada.</li>
                <li><strong>Pasajes por valor y por referencia:</strong>
                    <ul>
                        <li><strong>Por valor:</strong> Se pasa una copia del valor de la variable. Cualquier cambio dentro de la función no afecta a la variable original.
                            <pre><code class="language-c">
void modificarPorValor(int num) {
    num = num + 10;
    printf("Dentro de la función (por valor): %d\n", num);
}

int main() {
    int miNumero = 5;
    printf("Antes de la función (por valor): %d\n", miNumero); // 5
    modificarPorValor(miNumero); // Pasa una COPIA de miNumero
    printf("Después de la función (por valor): %d\n", miNumero); // Sigue siendo 5
    return 0;
}
                            </code></pre>
                        </li>
                        <li><strong>Por referencia:</strong> Se pasa la dirección de memoria de la variable. Los cambios dentro de la función afectan directamente a la variable original. (Se usa con punteros en C).
                            <pre><code class="language-c">
void modificarPorReferencia(int *pNum) { // Recibe un puntero a int
    *pNum = *pNum + 10; // Modifica el valor al que apunta el puntero
    printf("Dentro de la función (por referencia): %d\n", *pNum);
}

int main() {
    int miNumero = 5;
    printf("Antes de la función (por referencia): %d\n", miNumero); // 5
    modificarPorReferencia(&miNumero); // Pasa la DIRECCIÓN de miNumero
    printf("Después de la función (por referencia): %d\n", miNumero); // Ahora es 15
    return 0;
}
                            </code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Parámetros nominales y efectivos:</strong>
                    <ul>
                        <li><strong>Nominales (o formales):</strong> Los nombres de los parámetros definidos en la declaración o prototipo de la función (ej., `int a, int b` en `int sumar(int a, int b)`).</li>
                        <li><strong>Efectivos (o actuales):</strong> Los valores o variables reales que se pasan a la función cuando esta es invocada (ej., `5, 3` en `sumar(5, 3)`).</li>
                    </ul>
                </li>
                <li><strong>Recursividad:</strong> Es la técnica por la cual una función se llama a sí misma directa o indirectamente para resolver un problema. Es útil para problemas que pueden dividirse en subproblemas similares más pequeños.
                    <pre><code class="language-c">
// Ejemplo: Cálculo del factorial de un número usando recursividad
int factorial(int n) {
    if (n == 0) {
        return 1; // Caso base: factorial de 0 es 1
    } else {
        return n * factorial(n - 1); // Llamada recursiva
    }
}

int main() {
    int num = 4;
    printf("El factorial de %d es: %d\n", num, factorial(num)); // 24
    return 0;
}
                            </code></pre>
                </li>
                <li><strong>Modularización de un programa en varios archivos:</strong> Organizar el código de un proyecto grande en múltiples archivos `.c` (con la implementación de funciones) y archivos `.h` (cabeceras, con las declaraciones de funciones y estructuras), para mejorar la organización, compilación y reusabilidad.
                    <pre><code class="language-c">
// --- archivo: funciones.h ---
// Prototipo de la función
int sumar(int a, int b);

// --- archivo: funciones.c ---
#include "funciones.h" // Incluye el archivo de cabecera

int sumar(int a, int b) {
    return a + b;
}

// --- archivo: main.c ---
#include &lt;stdio.h&gt;
#include "funciones.h" // Incluye la cabecera de nuestras funciones

int main() {
    int resultado = sumar(10, 5);
    printf("Resultado de la suma: %d\n", resultado);
    return 0;
}
// Para compilar: gcc main.c funciones.c -o programa
                    </code></pre>
                </li>
            </ul>
        </section>

        <section class="unidad">
            <h3>UNIDAD 6 – Programación Orientada a Objeto (POO)</h3>
            <p>Esta unidad introduce un paradigma de programación fundamental en la industria actual, que permite diseñar software de manera más intuitiva, organizada y escalable, simulando entidades del mundo real.</p>
            <h4>Contenidos clave:</h4>
            <ul>
                <li><strong>Concepto de Programación orientada a objetos (POO):</strong> Un paradigma de programación que utiliza "objetos" como bloques fundamentales. Los objetos combinan datos (atributos) y el comportamiento (métodos) que opera sobre esos datos.
                    <p>Aunque C no es un lenguaje POO nativo, se pueden simular conceptos de POO usando estructuras y punteros a funciones.</p>
                </li>
                <li><strong>Diferencia entre programación estructurada y programación orientada a objetos:</strong>
                    <ul>
                        <li><strong>Estructurada:</strong> Se enfoca en procedimientos (funciones) que operan sobre datos separados.</li>
                        <li><strong>POO:</strong> Se enfoca en objetos que agrupan datos y los métodos que los manipulan, promoviendo la cohesión.</li>
                    </ul>
                </li>
                <li><strong>Beneficios de la aplicación de la programación orientada a objetos:</strong>
                    <ul>
                        <li><strong>Reusabilidad:</strong> El código de los objetos puede ser reutilizado en diferentes partes de un programa o en programas distintos.</li>
                        <li><strong>Mantenibilidad:</strong> El código es más fácil de depurar, modificar y mantener debido a su organización modular.</li>
                        <li><strong>Escalabilidad:</strong> Facilita el crecimiento y la adición de nuevas funcionalidades sin afectar el código existente.</li>
                        <li><strong>Legibilidad:</strong> El código es más comprensible al reflejar entidades del mundo real.</li>
                    </ul>
                </li>
                <li><strong>Principios de la programación orientada a objetos:</strong>
                    <ul>
                        <li><strong>Encapsulamiento:</strong> Agrupar datos y métodos que operan sobre esos datos dentro de una única unidad (el objeto), ocultando los detalles internos de implementación.
                            <pre><code class="language-c">
// Simulación de encapsulamiento en C con un struct y funciones
typedef struct {
    char nombre[50];
    int edad;
} Persona;

// Función para inicializar (constructor "simulado")
void inicializar_persona(Persona *p, const char *nom, int ed) {
    strcpy(p->nombre, nom);
    p->edad = ed;
}

// Función para mostrar datos (método "simulado")
void mostrar_persona(const Persona *p) {
    printf("Nombre: %s, Edad: %d\n", p->nombre, p->edad);
}

/*
int main() {
    Persona p1;
    inicializar_persona(&p1, "Ana", 25);
    mostrar_persona(&p1);
    return 0;
}
*/
                            </code></pre>
                        </li>
                        <li><strong>Herencia:</strong> Permite que una clase (clase hija) herede propiedades y comportamientos de otra clase (clase padre), promoviendo la reusabilidad del código. (Más complejo de simular directamente en C).</li>
                        <li><strong>Polimorfismo:</strong> La capacidad de que un objeto tome muchas formas o de que una misma interfaz pueda ser usada para diferentes tipos de datos o clases. Incluye la sobrecarga y la sobrescritura de métodos.</li>
                        <li><strong>Abstracción:</strong> Mostrar solo la información esencial al usuario y ocultar los detalles de implementación complejos.</li>
                    </ul>
                </li>
                <li><strong>Métodos con el mismo indicador y distinto número de parámetros:</strong> Esto se refiere a la **Sobrecarga de Métodos** (un tipo de polimorfismo estático), donde una clase puede tener múltiples métodos con el mismo nombre, pero que se diferencian por la cantidad o el tipo de sus parámetros. (No es una característica directa de C, pero se puede simular con nombres de funciones diferentes o macros).</li>
                <li><strong>Métodos Estáticos:</strong> Métodos que pertenecen a la clase misma, no a una instancia específica (objeto) de la clase. Se invocan directamente desde la clase y no pueden acceder a los atributos de instancia del objeto. (En C, esto serían funciones globales que operan sobre tipos de datos, sin requerir una instancia).</li>
                <li><strong>Recursividad de Métodos:</strong> Aplicación del concepto de recursividad (una función llamándose a sí misma) pero en el contexto de un método dentro de una clase, cuando la resolución del problema se presta a este enfoque.</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Tecnicatura Universitaria en Programación</p>
    </footer>
</body>
</html>
